/*
 * This work is licensed under the Creative Commons Attribution 3.0 Unported License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by/3.0/
 * or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.
 */

#ifndef SQMPACKETHANDLER_H
#define SQMPACKETHANDLER_H

// qt core libs
#include <QtCore/QObject>
#include <QtCore/QIODevice>
#include <QtCore/QVariant>
#include <QtCore/QtEndian>
#include <QtCore/QMutex>

// qt network libs
#include <QtNetwork/QTcpServer>
#include <QtNetwork/QTcpSocket>

// include ansi libs
#include <string>

//
// PACKETLENGTHTYPE
//
// The datatype will read at first from datastream to determinate the content length
// NOTE: this value has to be the same on client and server, if not, the packet parser will not work properly
//
#define PACKETLENGTHTYPE quint32

//
// PROPERTYNAME
//
// The property key will be used to store the non finished packet in the QObject meta system of the sending IODevice
// NOTE: don't use key names which start with _q_, because this will be used by Qt itself
//
#define PROPERTYNAME_PACKET "SQMPacketHandler_packet"

//
// DataPacket
//
// The DataPacket will be generated by the packet parser as result after successfully parse process of an packet!
//
struct DataPacket
{
    public:
        /// Reference counting implementation
        DataPacket()
        {
            this->mutex = new QMutex;
            this->intRefCounter = 1;

            // construct default values
            this->ioPacketDevice = 0;
            this->baRawPacketData = 0;
        }

        ~DataPacket()
        {
            // if ref counter is not 0, let the app crash!
            if(this->intRefCounter != 0) {
                qFatal("Try to delete a data packet, which still refer somewhere else (refounter: %i)", this->intRefCounter);
            }

            // ref counting system cleanup
            delete this->mutex;

            // data cleanup
            delete this->baRawPacketData;
        }

        void setRefCounter(int refCounter, bool threadSave = false)
        {
            // lock mutex, if user want thread safety
            if(threadSave) {
                this->mutex->lock();
            }

            // set ref counter
            this->intRefCounter = refCounter;

            // unlock mutex, if user want thread safety
            if(threadSave) {
                mutex->unlock();
            }
        }

        void increaseRefCounter(bool threadSave = false)
        {
            // lock mutex, if user want thread safety
            if(threadSave) {
                this->mutex->lock();
            }

            // increase ref counter
            this->intRefCounter++;

            // lock mutex, if user want thread safety
            if(threadSave) {
                mutex->unlock();
            }
        }

        friend class DataPacketDeallocater;

    private:
        // reference counting data
        int intRefCounter;
        QMutex *mutex;

        void free()
        {
            // get dataPacket mutex and lock it
            QMutex *mutex = this->mutex;
            mutex->lock();

            // decrease reference counter and grab the value
            int intRefCounter = (--this->intRefCounter);

            // release mutex
            mutex->unlock();

            // delete data packet after reference counter reached 0
            if(intRefCounter == 0) {
                delete this;
            }
        }

    public:
        // data helper
        virtual void moveFrom(DataPacket *dataPacketSrc, bool deleteSrc = false, bool threadSave = false)
        {
            // lock src and target mutex, if user want thread safety
            if(threadSave) {
                dataPacketSrc->mutex->lock();
                this->mutex->lock();
            }

            // move intRefCounter from dataPacketSrc to this
            this->intRefCounter = dataPacketSrc->intRefCounter;

            // move baRawPacketData from dataPacketSrc to this (be sure that no memory leaks occour!)
            if(this->baRawPacketData) {
                delete this->baRawPacketData;
            }
            this->baRawPacketData = dataPacketSrc->baRawPacketData;

            // move Datapacket data from src to this
            this->ioPacketDevice = dataPacketSrc->ioPacketDevice;
            this->intPacktLength = dataPacketSrc->intPacktLength;

            // if user want that the src becomes deleted,
            // construct default values in src (so that the deconstruction process doesn't fail)
            if(deleteSrc) {
                dataPacketSrc->baRawPacketData = new QByteArray;
                dataPacketSrc->setRefCounter(0, false);
                delete dataPacketSrc;
            }

            // release target mutex (and if user want no deletion of src the src mutex, too), if user want thread safety
            if(threadSave) {
                this->mutex->unlock();
                if(!deleteSrc) {
                    dataPacketSrc->mutex->unlock();
                }
            }
        }

        // data
        QIODevice* ioPacketDevice;
        QByteArray* baRawPacketData;
        PACKETLENGTHTYPE intPacktLength;
};

class DataPacketDeallocater
{
    public:
        DataPacketDeallocater(DataPacket* dataPacket)
        {
            this->dataPacket = dataPacket;
        }

        ~DataPacketDeallocater()
        {
            this->dataPacket->free();
        }

    private:
        DataPacket *dataPacket;
};

class IEleaph : public QObject
{
    Q_OBJECT
    public:
        // device forget options for device addings
        enum DeviceForgetOptions {
            ForgetDeviceOnClose = 0,
            ForgetDeviceOnDestroy = 2,
            NeverForgetDevice = 3
        };

        // start tcp listening
        bool startTcpListening(quint16 port, QHostAddress address = QHostAddress::Any);

        // static datapacket send functions
        static void sendDataPacket(QIODevice* device, QByteArray *baDatatoSend);
        static void sendDataPacket(QIODevice* device, std::string strDatatoSend);

    public slots:
        void addDevice(QIODevice* device, IEleaph::DeviceForgetOptions forgetoptions = IEleaph::ForgetDeviceOnDestroy);
        void removeDevice(QIODevice *device = 0);

    protected:
        // protected con and decon for inhertance override
        // set max length by default to 20MB (20971520 Bytes)
        IEleaph(quint32 maxDataLength = 20971520, QObject *parent = 0);
        ~IEleaph();

    protected:
        // virtual methods
        virtual void deviceAdded(QIODevice* device);
        virtual void deviceRemoved(QIODevice* device);
        virtual void packetDownloadProcess(QIODevice* device, qint64 downloadedBytes, qint64 totalBytes);
        virtual void newDataPacketReceived(DataPacket *dataPacket) = 0;

    private slots:
        void newTcpHost();
        void dataHandler();

    private:
        // dynamic members
        quint32 intMaxDataLength;

        // members for tcpserver feature
        QTcpServer serverTcp;
};

#endif // SQMPACKETHANDLER_H
